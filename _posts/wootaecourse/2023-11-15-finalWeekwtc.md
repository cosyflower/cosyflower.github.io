---
layout: single
title: "우아한테크코스 - 4주차 회고"
categories:
    - wootaecourse # category 일치했는지 확인하기 
tags:
    - ['4주차 과제 회고'] # tag도 마찬가지로 같이 띄울 수 있다 
toc: "true"
toc_sticky: "true"

date: 2023-11-15
last_modified_at: 2023-11-15
published: true # true로 변경하면 노출할 수 있음 

#toc: 목차 보이기 
#toc_sticky: 자동 스크롤 가능 
#date: 포스팅한 날자 
#last_modified_at: 마지막 수정 일자 
# [] 안에는 링크에 띄는 내용 ()안에는 링크 작성하기 [22.12.19 - 23.10.13](https://debonair-nigella-a88.notion.site/f71d32c1d1ef4cafbcd9fc77076b36a8?pvs=4)
#bundle exec jekyll serve - test 하는 방법 
#published: true
#br : 개행하기 
#hr : 개행 줄이 같이 출력되는 상황 

#<mark style='background-color: #f6f8fa'>우아한테크코스 프리코스가 드디어 시작했다!! 1주차 과제는 바로 숫자 야구 게임이였다</mark>
#<br>

# 이전에 김영한님 강의를 들었던 기억도 있었고 MVC 패턴을 검색하다가
# ```java
---
# 우아한테크코스 프리코스
> 4주차 과제를 마치고 난 이후 회고하며 정리한 글입니다 

## 코드의 무한 뒤엎기
<mark style='background-color: #f6f8fa'>뒤엎는 과정의 연속</mark>
<br>
마지막 미션인 크리스마스 미션을 진행하면서 정말 많은 뒤엎기?가 있었다.
어떤 코드가 좋을지 스스로 많이 고민하면서 리팩토링을 동시에 진행했고, 테스트 코드까지 작성하려니
<br>
여간 쉬운 일은 아니었다. 
<br>
하지만 명확하게 느낄 수 있었던 것은 "클래스 기획의 영향력"을 뼈저리게 느낄 수 있었다
<br>
TDD 방식을 활용하고자 작은 기능에 초점을 두었던 지난 학습에 비해서 이번에는
<br>
프로그램의 목표가 무엇인지를 명확하게 이해하려고 한 부분이 정말 큰 도움을 줬다 
<br>
전체 틀을 먼저 확인하고 작은 기능으로 가는, 역방향의 본석을 하면서 절대적으로 필요한 정보를 빠르게 유추할 수 있었다
<br>
역으로 찾아가는, 필요성을 인지하고 구현하는 작은 기능들에 더 초점을 둔 상황에서 코드 작성이 원활한 것을 느낄 수 있었다

## 이번 미션의 핵심을 정리해보면

![image](https://github.com/woowacourse-precourse/java-lotto-6/assets/128453459/f13f9a29-f6fb-49c0-b804-be10455e77d5)


### 4주차 미션을 들어가기 전 
<hr>
> 미션 이메일 요구사항 그리고 공통 피드백을 반영한 내용입니다 

<mark style='background-color: #f6f8fa'>이메일 요구 사항</mark>
<br>
- 클래스의 역할 책임을 생각하기 
- 클래스 작성 시 도메인 로직에 집중하기 (도메인에 더 집중할 것 / UI와 구분해서 구현하기) 
- UI는 도메인 로직과 분리하는 방향으로 생각하기 
- 느낀 점을 소감문으로 작성하기. 학습한 과정을 잘 드러내 주세요

<mark style='background-color: #f6f8fa'>공통 피드백</mark>
<br>
-> 해당 역할을 수행하는 다른 클래스나 객체가 없을지 고민해봐야 한다 
    - 너무 많은 역할을 수행하고 있는 함수, 객체를 어떻게 분할 할지를 고민해야 할 필요가 있다 

<mark style='background-color: #f6f8fa'>함수 분리, 그리고 기능의 분리</mark>
<br>
-> View에서 사용할 데이터는 어쩔 수 없이 getter 메서드를 적용할 수 밖에 없다 
-> 필드 수를 줄이기 위해선 결국 클래스의 분리를 더 강력하게 호소하는 바와 같다고 생각한다
-> 필드 중 일부를 하나로 묶을 수 있는 클래스를 정의한다면 인스턴스 변수의 수를 줄일 수 있다고 생각한다 
-> Private 메서드를 테스트해야 한다면 메서드의 분리를 진행하자 

**필드 수를 줄이기 위해선 결국 클래스의 분리를 더 강력하게 호소하는 바와 같다고 생각한다**
**필드 중 일부를 하나로 묶을 수 있는 클래스를 정의한다면 인스턴스 변수의 수를 줄일 수 있다고 생각한다**

### 함수를 분리하라는 말, 클래스를 분리한다는 말은
<hr>
<mark style='background-color: #f6f8fa'>역할들이 존재하고, 해당 역할들을 서로 다른 클래스로 분배하는 연습을 의미한다 </mark>
<br>
<br>
3주차 소감문을 작성하면서 위의 요구 사항을 처음 접했을 때 어떤 내용을 의미하는지를 곰곰이 생각한 적이 있다 
<br>
"객체지향의 오해와 사실" 책에서 언급한 객체지향적 관점을 토대로 생각을 해보았다 
<br> 
프로그램은 기본적으로 협력을 요구하고 있는 상황이다. 협력 간 어떤 기능들이 오고가야 하는지를 살펴볼 필요가 있다 
<br>
<br>
기능이 존재한다는 것은 SRC -> DST 의 기본 관계를 구축할 수 있다. 특정 메서드를 요청하는 셈이다. 인자'가' 영향을 미친다 
<br>
메서드를 요청했으니 반대로 SRC <- DST 의 기본 관계도 생각할 수 있다. 반환 타입'에' 영향을 미친다 
<br>
<br>
여기서 중요한 점은 메서드를 요청했을 때 기본적으로 메서드에 대한 반환값은 요청을 보낸 클래스가 기대하는 것이 아닌 요청을 받은 클래스에서
<br>
스스로 자신의 로직에 따라 행동을 진행한 다음 결과를 반환하는 사실에 명심해야 한다. 
<br>
필요한 협력, 협력에서 요구하는 책임, 해당 책임을 맡은 역할을 어느 정도 규정한 상황에서 TDD 방식을 활용하는게 좋다고 생각했다
<br>
<br>
위의 협력 관계 조차 제대로 이해하지 못하는 경우에 바로 TDD를 사용해도 좋지만, 내가 특정 클래스를 형성하는 과정에서
<br>
당위성을 명확하게 알고 있어야 구현하는데 문제 없이 진행할 수 있다는 걸 뼈저리게 느꼈기 때문이다 

> 바로 TDD 방식을 적용하는 것보다, 프로그램의 목적과 의도를 먼저 이해하고 필요한 정보와 정보들을 담는 클래스를 역으로 생각해가면서 큰 틀의 기능에서 작은 기능으로 자연스럽게 이어지는 방향이 제일 좋다고 생각한다. 왜 클래스가 필요하고, 해당 클래스에서 어떤 기능을 요구하는지를 다시 한 번 새기며 진행할 수 있다는 장점을 지닌다고 생각한다. 이러지도, 저러지도 못하는 상황이라면 한 줄이라도 코드를 끄적이는게 제일 좋다. 

## 미션을 수행하며
<mark style='background-color: #f6f8fa'>최대한 클래스를 분리하려고 했다</mark>

> 공통적인 틀, template을 만드는 것에 집중하지 말고 유연한 사고를 지녀야 한다

처음에는 사소한 기능, 사소한 도메인부터 해결하려 했다. 구체적인 로직을 진행하기에 앞서 작은 크기의 클래스를 설계하려고 했다
<br>
이런 과정에서 정말 큰 도움을 주는 TDD방식이다. 시작이 반이라는 이야기가 굳이 나온 말이 아니란 걸 느꼈다
<br>
<br>
다만 목적없는 설계는 그리 좋지 못하다고 생각했다. 이유는 간단하다. 구현을 하는 과정에서 끊임없는 고민들과 맞서야 하기 떄문이다
<br>
사전에 방지하기 위해서는 큰 틀을 이해해야 한다. 내가 이 클래스를 설계해야 하는 명확한 이유를 알아야 한다
<br>
<br>
따라서 먼저 프로그램의 의도가 무엇인지 부터 생각했다 

### 프로그램의 의도는 "이벤트별 할인 금액 구하기"로 생각했다 
<hr>
![image](https://github.com/cosyflower/MyStrategy/assets/128453459/2346f283-03e5-44a1-b895-09d1d96c6805)

의도에 맞는 클래스를 생각하면 "이벤트"는 절대적으로 필요한 요소이다. 이벤트에 맞게 할인 금액을 도출해야 하기 때문이다 
<br>
전체 의도를 어느 정도 이해했다면 구체적으로 기능 명세 사항을 읽을 시간이 되었다는 뜻 

### 이벤트의 구성
<hr>
> 이벤트는 이름, 조건 그리고 효과로 구성되어 있다 

무조건 3가지로 구성되어 있다고 생각할 수는 없지만 전체적으로 기능을 읽다보면 요구하는 사항은 3가지로 크게 정리할 수 있다
<br>
구체적으로 생각하면서도 쉽게 적용하는 사고가 정말 중요하다고 생각한다 
<br>
<br>
여기서 눈여겨 봐야 하는 내용은 바로 이벤트의 조건과 효과이다. 
<br>
이름은 독립적인 상황이기 때문에 매칭만 이뤄지면 되는 생각 하지만 조건과 효과는 명확하게 구분을 지을 수 있어야 한다 

### 첫 번째 고민
<hr>
<mark style='background-color: #f6f8fa'>특정 항목에서만 적용되는 경우를 어떻게 해결할 것인가</mark>

구체적으로 작성하자면 공통으로 적용되는 사항이 존재하는 상황에서 특정 항목만 추가적으로 적용되는 조건들을 어떤 방식으로 해결할 것인지이다
<br>

- 방법 1 모두 날짜의 영향을 받도록 구현. 증정 이벤트에 추가적으로 조건을 붙이는 방식
- 방법 2 증정 이벤트 제외 날짜의 영향을 받도록 구현하고, 증정만 날짜를 기준으로 구현하는 방식 (2번 선택했다)

공통적으로 적용되는 사항을 미리 깔아둔 상황에서 추가하는 방향이 더 옳다고 생각했다. 추후의 확장성 측면에서도 더 유리하다고 생각했다.
<br>
개인적으로, 객체지향에서 공통적으로 적용되는 상황이나 기능을 엄청 신경쓰는 타입이다. 
<br>
<br>
명백한 리팩토링의 순간이기도 하고, 코드는 무엇보다 "반복"을 싫어하기 떄문이다 
<br>
공통적으로 진행되는게 있다는 것은 분명 더 좋은 방향의 코드를 작성할 수 있다는 걸 암시한다고 생각한다. 그래서 2번을 선택했다 

### 이벤트를 구성했다면
<hr>
<mark style='background-color: #f6f8fa'>지금 왜 이벤트를 먼저 구현했는지 다시 한 번 짚고 넘어가자</mark>

엄청 사소한 일이라고 생각하지만, 정말 정말 필수적인 습관이다. 
<br>
클래스를 구현한 이후에, 구현한 이유를 다시 짚고 가는 것은 정말 중요하다. 의도적으로 계속 생성 이유를 암시해야 코드 작성의 정당성을 유지할 수 있다
<br>
<br>
이벤트를 구성한 이유는 이벤트를 통해서 할인 금액을 알 수 있기 떄문이다. 
<br>
이벤트를 구현하는 과정에서 자연스럽게 총 주문 금액도 존재하고, 주문 메뉴의 종류도 요구되는 것을 알 수 있다 

> 매우매우 중요한 시점이다. 내가 먼저 예측하는 것이 아니라, 프로그램이 "요구하는 것을 그대로 반영하고 있다"

> 요구하는 것에 집중하자. 내가 먼저 손을 쓰려고 하지 말자. 자연스럽게 코드의 흐름에 따르라는 것이 정말 중요하다 

### 주문 메뉴의 종류도 필요하고 총 주문 금액도 필요하네?
<hr>
<mark style='background-color: #f6f8fa'>지금 요구하고 있는 정보가 무엇이지?</mark>

![image](https://github.com/cosyflower/MyStrategy/assets/128453459/9e4c02aa-67f1-44cf-a7e2-505b9217ae25)

1. 주문 메뉴의 종류
2. 총 주문 금액

총 주문 금액에서 큰 힌트를 얻을 수 있다 

### 두번째 고민
<hr>
<mark style='background-color: #f6f8fa'>기능의 flow를 작성하면 기존의 클래스를 활용할 지 혹은 새로운 클래스 생성 고민한다</mark>

생성한 기존의 클래스를 이용할지, 새로운 클래스를 구성할지 매번 고민할 수 밖에 없다
<br>
오히려 위의 고민을 하고 있지 않는다면, 객체지향적 관점에서 벗어났는지를 의심해야 한다, 아니 벗어났을지도 모른다 
<br>
<br>
구분하는 방식은 기존 클래스에 내가 원하는 책임을 부여해도 되는지? 를 생각하면 쉽다
<br>
어떠한 클래스에도 적용되지 못한다면 -> 새로운 클래스를 형성하는 것이 맞다 

![image](https://github.com/cosyflower/MyStrategy/assets/128453459/5de437d1-dc90-4ef8-b1d5-f6748f6085fb)


### 지켜야 할 사항
<hr>
1. 급하게 하지 말기
    - 예외 하나 당 테스트 하나씩 작성하는게 좋다
    - 나중에 밀려서 진행하는 테스트는 정말 무의미하다고 했었다 

2. 테스트를 진행할 때 계속해서 틀을 고착화하려 하지 말자 
    - 핵심이 되어야 하는 기능을 먼저 생각한다
    - 테스트를 작성할 때 필요한 정보가 무엇인지를 생각한다 

3. 세팅해야 하는 정보 파악하기
    - 대표적으로 모든 흐름을 파악했을 때 근간이 되어야 하는 클래스들을 우선적으로 설계하고 코딩을 하자는 말

### 코드 구조
<hr>
```markdown
christmas                                      
├─ controller                                  
│  ├─ display                                  
│  │  ├─ DisplayAcceptedOrdersController.java  
│  │  ├─ DisplayBadgeController.java           
│  │  ├─ DisplayBenefitController.java         
│  │  └─ DisplayController.java                
│  └─ register                                 
│     ├─ RegisterAbstractController.java       
│     ├─ RegisterController.java               
│     ├─ RegisterDayController.java            
│     └─ RegisterOrderController.java          
├─ domain                                      
│  ├─ discount                                 
│  │  ├─ DiscountChecker.java                  
│  │  ├─ DiscountEvent.java                    
│  │  ├─ DiscountEventName.java                
│  │  ├─ DiscountPrice.java                    
│  │  └─ DiscountType.java                     
│  ├─ menu                                     
│  │  ├─ MenuName.java                         
│  │  ├─ MenuPrice.java                        
│  │  ├─ MenuProduct.java                      
│  │  └─ MenuType.java                         
│  ├─ order                                    
│  │  ├─ AcceptedOrders.java                   
│  │  ├─ MenuQuantity.java                     
│  │  └─ Order.java                            
│  ├─ receipt                                  
│  │  ├─ EventBadge.java                       
│  │  ├─ EventStatus.java                      
│  │  └─ TotalPrice.java                       
│  └─ reservation                              
│     ├─ Day.java                              
│     └─ EventReservation.java                 
├─ dto                                         
│  ├─ DayDTO.java                              
│  └─ OrderDTO.java                            
├─ system                                      
│  └─ PlannerApplication.java                  
├─ util                                        
│  ├─ Constants.java                           
│  ├─ Mapper.java                              
│  └─ Util.java                                
├─ view                                        
│  ├─ InputView.java                           
│  └─ OutputView.java                          
└─ Application.java                            
```

### 해결하지 못한 고민들
<hr>
<mark style='background-color: #f6f8fa'>난제!</mark>

> Getter를 지양하라고 했는데. .

-> 원시값을 포장하려다보니 getter를 사용하지 않을래야 않을 수가 없었다
-> Primitive 한 애들을 접근하는 과정에서는 Value 네이밍을 추가적으로 작성했다 
-> 하나의 클래스 내에 미리 getter 끝까지 선언을 해서 한번에 원시값을 알아가는 저 과정이 괜찮은 것일까?? 
<br>
결과적으로 View를 위한 데이터를 전달하는 과정에서 getter를 사용하지 않을 수는 없다!

> equals(), hashCode() 는 언제 적용해야 하는지 생각하기

isEqualTo() 를 적용하는 과정에서 오버라이드를 진행하지 않으면 애초에 비교 자체가 되지 못했다. 테스트 코드를 작성하는 과정에서 자연스럽게 오버라이드 했다 
-> 동등성을 위한 방식 (주소값은 서로 달라도 상태값은 같구나! 라고 말할 수 있다) 
-> 상태가 달라도 주소값이 같다면 같은 거다 - 동일성 
<br>

> 원시값으로 값을 형성한 다음에 출력을 진행할 때도 마찬가지로 포장을 진행해야 하는지, 그 원리를 아직은 잘 모르겠다 

이 부분은 정말 모르겠다. . .





***
    
    진정한 경쟁력은 자신의 가치를 공유하는 것


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}